using Test
using QuadraticSweep
using Random
using Combinatorics
using Statistics

mutable struct Dataset
    s_xx::Float64
    s_xy::Float64
    s_yy::Float64
    s_x::Float64
    s_y::Float64
    n::Int64
    j::Float64
    points::Vector{Tuple{Float64, Float64}}  # Array to track the values we're adding

    function Dataset(s_xx = 0.0, s_xy = 0.0, s_yy = 0.0, s_x = 0.0, s_y = 0.0,
            n = 0, j = -Inf, points = Vector{Tuple{Float64, Float64}}())
        return new(s_xx, s_xy, s_yy, s_x, s_y, n, j, points)
    end
end

# Update current dataset with x and y, and update the scoring function
function update!(r::Dataset, x::Float64, y::Float64, J::Function)
    r.s_xx += x * x
    r.s_xy += x * y
    r.s_yy += y * y
    r.s_x += x
    r.s_y += y
    r.n += 1
    push!(r.points, (x, y))  # Track the point being added
    r.j = J(r)
end

# Backtrack (undo) the addition of x and y from the dataset
function backtrack!(r::Dataset, x::Float64, y::Float64, J::Function)
    r.s_xx -= x * x
    r.s_xy -= x * y
    r.s_yy -= y * y
    r.s_x -= x
    r.s_y -= y
    r.n -= 1
    if !isempty(r.points)
        pop!(r.points)  # Remove the last point added
    end
    r.j = J(r)
end

# Copy values from current dataset `r` to best dataset `best`, including the points array
function update_best!(best::Dataset, current::Dataset)
    best.s_xx = current.s_xx
    best.s_xy = current.s_xy
    best.s_yy = current.s_yy
    best.s_x = current.s_x
    best.s_y = current.s_y
    best.n = current.n
    best.j = current.j
    best.points = current.points  # Copy the points so backtracking doesn't affect the best
    current.points = []
end

# Recursive scoring function
function score!(r::Dataset, Tc::Array, T::Array, J::Function, best::Dataset)
    if isempty(T)
        # Base case: if the current score is better, update best in-place
        if r.j > best.j
            update_best!(best, r)
        end
        return best  # Return the best dataset
    end

    # Branch 1: Exclude current point from T and update with Tc
    update!(r, Tc[1, 1], Tc[1, 2], J)
    best = score!(r, Tc[2:end, :], T[2:end, :], J, best)
    backtrack!(r, Tc[1, 1], Tc[1, 2], J)  # Undo update after recursion

    # Branch 2: Include the current point from T
    update!(r, T[1, 1], T[1, 2], J)
    best = score!(r, Tc, T[2:end, :], J, best)
    backtrack!(r, T[1, 1], T[1, 2], J)  # Undo update after recursion

    # Return the best dataset
    return best
end

# Initial function to set up and call the recursive score function
function score!(Tc::Array, T::Array, J::Function)
    root = Dataset()  # Initial empty dataset
    best = Dataset()  # Keep track of the best result in another dataset
    return score!(root, Tc, T, J, best)
end

function brute_force(Tc, T, J)
    best_set = nothing
    best_score = -Inf
    d = size(T, 1)
    idxs = 1:d
    for set in powerset(1:d)
        k = length(set)
        T_sub = T[set, :]
        Tc_sub = Tc[1:(d - k), :]
        dset = vcat(T_sub, Tc_sub)
        score = J(dset)
        if score > best_score
            best_set = dset
            best_score = score
        end
    end
    return best_set, best_score
end

@testset "Score Function Tests" begin
    function J_test(d::Dataset)
        num = (d.s_xy - 1 / d.n * d.s_x * d.s_y)^2
        den = (d.s_xx - 1 / d.n * d.s_x^2) * (d.s_yy - 1 / d.n * d.s_y^2)
        return num / den
    end

    # Random.seed!(123)
    n = 20
    d = 7

    # Example test data
    Tc_x = sort(rand(n), rev = true)
    T_x = sort(rand(d), rev = true)
    Tc = reshape(vcat(Tc_x, Tc_x), (n, 2))
    T = reshape(vcat(T_x, T_x), (d, 2))

    grd_set, grd_score = brute_force(Tc, T, (x) -> cor(x[:, 1], x[:, 2])^2)

    # Call the score function
    best_dataset = score!(Tc, T, J_test)

    @test best_dataset.j ≈ grd_score
    # @test best_dataset.points ≈ grd_set

end
